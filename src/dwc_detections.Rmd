---
title: "Import detections data"
subtitle: "ETN - LifeWatch.be acoustic telemetry data of fish"
author:
- Lien Reysehove
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

# Setup 

```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

# Install packages

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(etn)            # To interact with ETN
library(lubridate)      # To process date and time information
library(glue)
library(odbc)
```

# Read source data

Get username/password from environment (therefore requires this script to be run on <http://rstudio.lifewatch.be>) and connect to database:

```{r}
my_con <- connect_to_etn(Sys.getenv("username"), Sys.getenv("password"))
```

# Inspect datasets

Create view of `vliz.detections_view`:

```{r}
query <- glue_sql(
    "SELECT *
    FROM vliz.detections_view
    LIMIT 100000
    ",
    .con = my_con)
  
detections_subset <- dbGetQuery(my_con, query)
as_tibble(detections_subset)
```

Create view of `vliz.animals_view`:

```{r}
query <- glue_sql(
    "SELECT *
    FROM vliz.animals_view
    LIMIT 100000
    ",
    .con = my_con
  )
  
animals_subset <- dbGetQuery(my_con, query)
as_tibble(animals_subset)
```

Create view of `vliz.deployments_view`:

```{r}
query <- glue_sql(
    "SELECT *
    FROM vliz.deployments_view
    LIMIT 100000
    ",
    .con = my_con
  )
  
deployments_subset <- dbGetQuery(my_con, query)
as_tibble(deployments_subset)
```

The query returns a dataset of 3248 records. This means that the `deployments_subset` actually includes all data from `vliz.deployments_view`. 

```{r}
deployments <- deployments_subset
```

Create view of `vliz.receivers`:

```{r}
receivers_query <- glue_sql("
      SELECT * 
      FROM vliz.receivers
      LIMIT 100000
",
.con = my_con
  )

receivers_subset <- dbGetQuery(my_con, receivers_query)
as_tibble(receivers_subset)
```

# Select transmitter and receiver information

We select all transmitter and receiver information (see [ETN Data Policy](http://www.lifewatch.be/etn/assets/docs/ETN-DataPolicy.pdf)):

> Receiver moratorium: there is no moratorium for receiver information. 
> Tag moratorium: there is no moratorium for tag information.
> Deployment moratorium: there is no moratorium for deployment information. All
metadata is made publicly available immediately after installation. All open
deployments (i.e. without an end date) will be visualized on a map on the ETN Data
Portal. In exceptional cases, a deployment moratorium can be requested, with the ETN
Data Committee reviewing requests. 

## Explore deployment information

### Receiver

```{r}
deployments %>% group_by(receiver) %>% count() %>% arrange(desc(n))
```

### Receiver status

```{r}
deployments %>% group_by(receiver_status) %>% count() %>% arrange(desc(n))
```

### Project name

```{r}
deployments %>% 
  group_by(projectname) %>% 
  count() %>% 
  arrange(projectname)
```

Check which of these projectnames are no valid network project (should be zero):

```{r}
deployments %>% 
  group_by(projectname) %>% 
  count() %>% 
  arrange(projectname) %>% 
  anti_join(
    select(get_projects(my_con, project_type = "network"), name),
    by = c("projectname" = "name")
)
```

### Drop dead date

```{r}
deployments %>% group_by(drop_dead_date) %>% count() %>% arrange(desc(n))
```

### deploy_date time and recover_date_time

Inspect both `deploy_date_time` and `recover_date_time`:

```{r}
deployments %>% 
  group_by(deploy_date_time, recover_date_time) %>% 
  count() %>% 
  arrange(desc(n))
```

Check for empty values in `deploy_date_time`, `recover_date_time` or both:

```{r}
deployments %>% 
  mutate(deploy_date_time = as.character(deploy_date_time)) %>% 
  mutate(recover_date_time = as.character(recover_date_time)) %>% 
  mutate(empty_dates = case_when(
    is.na(deploy_date_time) & !is.na(recover_date_time) ~ "no deploy date",
    !is.na(deploy_date_time) & is.na(recover_date_time) ~ "no recover date",
    is.na(deploy_date_time) & is.na(recover_date_time) ~ "no date",
    TRUE ~ "date")) %>% 
  group_by(empty_dates) %>% 
  count()
```

All receivers except one have at least a deployment date.
Retrieve record for which there is no date information whatsoever:

```{r}
deployments %>% 
  mutate(deploy_date_time = as.character(deploy_date_time)) %>% 
  mutate(recover_date_time = as.character(recover_date_time)) %>% 
  mutate(empty_dates = case_when(
    is.na(deploy_date_time) & !is.na(recover_date_time) ~ "no deploy date",
    !is.na(deploy_date_time) & is.na(recover_date_time) ~ "no recover date",
    is.na(deploy_date_time) & is.na(recover_date_time) ~ "no date",
    TRUE ~ "date")) %>% 
  filter(empty_dates == "no date") %>% 
  select(receiver, receiver_status, projectname, id_pk)
```

Retrieve receiver deployments for which `recover_date_time` falls before `deploy_date_time`:

```{r}
deployments %>% 
  mutate(deploy_date_time = as.character(deploy_date_time)) %>% 
  mutate(recover_date_time = as.character(recover_date_time)) %>% 
  mutate(empty_dates = case_when(
    is.na(deploy_date_time) & !is.na(recover_date_time) ~ "no deploy date",
    !is.na(deploy_date_time) & is.na(recover_date_time) ~ "no recover date",
    is.na(deploy_date_time) & is.na(recover_date_time) ~ "no date",
    TRUE ~ "date")) %>% 
  filter(recover_date_time < deploy_date_time) %>% 
  arrange(receiver) %>% 
  select(receiver, recover_date_time, deploy_date_time, id_pk, projectname)
```

### Bottom depth, riser_length, instrument_depth

```{r}
deployments %>% 
  group_by(bottom_depth, riser_length, instrument_depth) %>% 
  count() %>% 
  arrange(desc(n))
```

Unit of `bottom_depth`: metres
Unit of `riser_length`: metres
unit of `instrument_depth`: metres

Select those records with a unit in `bottom_depth` (see #58)

```{r}
deployments %>% 
  filter(str_detect(bottom_depth,"m")) %>% 
  select(receiver, id_pk, bottom_depth, projectcode) %>% 
  arrange(receiver)
```

### UTC synchronisation date time

```{r}
deployments %>% 
  group_by(sync_date_time) %>% 
  count() %>% 
  arrange(desc(n))
```

### Comments

```{r}
deployments %>% 
  group_by(comments) %>% 
  count() %>% 
  arrange(desc(n))
```

### id_pk

Should all be unique (output should be empty)

```{r}
deployments %>% get_dupes(id_pk)
```

### location name

```{r}
deployments %>% 
  filter(!is.na(location_name) | location_name == "") %>%
  group_by(location_name, projectname) %>% 
  count() %>% 
  arrange(location_name)
```


# Detection date information

Inspect date information present in `vliz_deployments.view`:

```{r}
query <- glue_sql(
    "SELECT receiver, drop_dead_date, download_date_time, deploy_date_time, recover_date_time
    FROM vliz.deployments_view
    WHERE receiver IN ({receiver*})
    ORDER BY receiver
    ",
    receiver = receivers,
    .con = my_con)

query_output <- dbGetQuery(my_con, query)
as_tibble(query_output)
```

## Deployment date

Check `deploy_date_time`, `recover_date_time` and `comments`

```{r}
query <- glue_sql(
    "SELECT deploy_date_time, recover_date_time, comments 
    FROM vliz.deployments_view
    LIMIT 1000",
    .con = my_con)

deployments <- dbGetQuery(my_con, query)
as_tibble(deployments)
```

Check whether `deploy_date_time` falls before `recover_date_time`:

```{r}
query <- glue_sql(
    "SELECT receiver, deploy_date_time, recover_date_time, comments 
    FROM vliz.deployments_view
    WHERE deploy_date_time > recover_date_time
    ORDER BY receiver",
    .con = my_con)

deployments <- dbGetQuery(my_con, query)
as_tibble(deployments)
```




Check for empty date information for `deploy_date_time`:

```{r}
query <- glue_sql(
    "SELECT receiver, deploy_date_time 
    FROM vliz.detections_view
    WHERE transmitter IN ({transmitter*})
      AND deploy_date_time IS NULL
    LIMIT 10",
    transmitter = transmitter,
    .con = my_con)

query <- dbGetQuery(my_con, query)
as_tibble(query)

```

Check whether `deploy_date_time` in `vliz_detection.view` is included in and equals information in the  `vliz_deployments_view` column with the same name:

```{r}
query <- glue_sql(
    "SELECT a.deployReceiver, a.deployDate, b.detectReceiver, b.detectDate
     FROM
        (SELECT count(receiver), receiver AS deployReceiver, deploy_date_time AS deployDate
        FROM vliz.deployments_view
        WHERE receiver IN ({receiver*})        
        GROUP BY deployReceiver, deployDate)  a
    FULL JOIN 
        (SELECT count(receiver), receiver AS detectReceiver, deploy_date_time AS detectDate
        FROM vliz.detections_view
        WHERE transmitter IN ({transmitter*})        
        GROUP BY detectReceiver, detectDate) b
    ON a.deployReceiver = b.detectReceiver AND a.deployDate = b.detectDate
    ",
    receiver = receivers,
    transmitter = transmitter,
    .con = my_con)

deployment_date_time <- dbGetQuery(my_con, query)
as_tibble(deployment_date_time)
```

All receiver x date information combinations from the detections table should be included in the deployments table, i.e. `deployreceiver` should not contain empty values after this join:

```{r}
deployment_date_time %>% filter(is.na(deployreceiver))
```

In some cases, a given receiver will not detect any of the targeted transmitters. These receiver x date information might be excluded from the Darwin Core mapping.

```{r}
deployment_date_time %>% filter(is.na(detectreceiver))
```

This code inspects whether `drop_dead_date` falls before `deploy_date_time`:

```{r}
deployments_query <- glue_sql(
    "SELECT count(receiver), receiver
    FROM vliz.deployments_view
    WHERE 
        receiver IN ({receiver*})
        AND drop_dead_date < deploy_date_time
    GROUP BY receiver
    ORDER BY count(receiver) DESC
    ",
    receiver = receivers,
    .con = my_con)

deployment_dates <- dbGetQuery(my_con, deployments_query)
as_tibble(deployment_dates)
```

# Location information

Inspect `station_name`, `location_name` and `location_description`:

```{r}
query <- glue_sql(
    "SELECT COUNT(receiver), receiver, station_name, location_name, location_description
    FROM vliz.deployments_view
    GROUP BY receiver, station_name, location_name, location_description
    ORDER BY station_name",
    .con = my_con)

station_names <- dbGetQuery(my_con, query)
as_tibble(station_names)
```


```{r}
query <- glue_sql(
    "SELECT COUNT(location_name), station_name, location_name, location_description
    FROM vliz.deployments_view
    GROUP BY station_name, location_name, location_description
    ORDER BY station_name",
    .con = my_con)

deployment_locations <- dbGetQuery(my_con, query)
as_tibble(deployment_locations)
```

Make subsets to make the interpretation easier:

1. Inspect empty values for `station_name`:

```{r}
query <- glue_sql(
    "SELECT COUNT(location_name), station_name, location_name, location_description
    FROM vliz.deployments_view
    WHERE station_name = '' OR station_name IS NULL
    GROUP BY station_name, location_name, location_description
    ORDER BY station_name",
    .con = my_con)

deployments <- dbGetQuery(my_con, query)
as_tibble(deployments)
```

Conclusion: `station_name` is almost always provided. We use this as main determinant of `locality`. 

```{r}
query <- glue_sql(
    "SELECT DISTINCT station_name, location_name
    FROM vliz.deployments_view
    WHERE NOT (station_name = '' OR station_name IS NULL)
    ORDER BY station_name",
    .con = my_con)

localities <- dbGetQuery(my_con, query)
as_tibble(localities)
```

Export location information for further interpretation:

```{r}
write.csv(localities, "../data/interim/localities.csv")
```



2. Inspect empty values for `location_name`:

```{r}
query <- glue_sql(
    "SELECT COUNT(location_name), station_name, location_name, location_description
    FROM vliz.deployments_view
    WHERE (location_name = '' or location_name is NULL)
    GROUP BY station_name, location_name, location_description
    ORDER BY station_name",
    .con = my_con)

deployments <- dbGetQuery(my_con, query)
as_tibble(deployments)
```

In 84 cases, no location_name is provided. We will map `station_name` _only_ in that case.

3. Inspect non-empty values for `location_description`:

```{r}
query <- glue_sql(
    "SELECT COUNT(location_name), station_name, location_name, location_description
    FROM vliz.deployments_view
    WHERE NOT (location_description = '' or location_description is NULL)
    GROUP BY station_name, location_name, location_description
    ORDER BY station_name",
    .con = my_con)

deployments <- dbGetQuery(my_con, query)
as_tibble(deployments)
```